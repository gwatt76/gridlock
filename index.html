<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gridlock: Retro Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');
        
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-primary: #0a0e14;
            --bg-secondary: #1a1f2e;
            --bg-tertiary: #252b3b;
            --grid-line: #2a3441;
            --accent: #00d4aa;
            --player1: #ff6b6b;
            --player2: #4ecdc4;
            --player3: #ffe66d;
            --player4: #a29bfe;
            --danger: #ff4757;
        }

        body {
            font-family: 'Share Tech Mono', monospace;
            background: var(--bg-primary);
            color: #e8eaed;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            overflow: hidden;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 0.2em;
            color: var(--accent);
            text-shadow: 0 0 10px var(--accent);
            margin-bottom: 5px;
        }

        .board-container {
            position: relative;
            background: var(--bg-secondary);
            border: 2px solid var(--grid-line);
            border-radius: 8px;
            padding: 10px;
            overflow: hidden;
        }

        .board-container::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            z-index: 10;
            background-size: 100% 3px, 3px 100%;
            pointer-events: none;
        }

        #game-canvas { display: block; cursor: crosshair; touch-action: none; }

        .btn {
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--grid-line);
            color: var(--accent);
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            text-transform: uppercase;
            transition: 0.2s;
            font-size: 0.8rem;
        }

        .btn:hover { background: var(--accent); color: var(--bg-primary); box-shadow: 0 0 15px var(--accent); }
        .btn-yield { color: var(--danger); border-color: var(--danger); margin-top: 10px; }
        .btn-yield:hover { background: var(--danger); color: white; box-shadow: 0 0 15px var(--danger); }

        #setup-screen, #game-screen { width: 100%; max-width: 500px; text-align: center; }
        .form-group { margin-bottom: 15px; text-align: left; }
        input, select { width: 100%; padding: 10px; background: #000; color: var(--accent); border: 1px solid var(--grid-line); }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center; z-index: 100;
        }
        .modal-content { background: var(--bg-secondary); padding: 30px; border: 2px solid var(--accent); text-align: center; max-width: 400px; }
        
        .help-text { text-align: left; font-size: 0.9rem; line-height: 1.4; color: #ccc; margin: 15px 0; }
        .help-text b { color: var(--accent); }
    </style>
</head>
<body>

    <h1>GRIDLOCK</h1>
    <p style="color: var(--accent); font-size: 0.7rem; letter-spacing: 0.2em; margin-bottom: 20px;">VINTAGE PROTOCOL</p>

    <div id="setup-screen">
        <div class="form-group">
            <label>GRID SIZE</label>
            <input type="number" id="grid-size" value="12">
        </div>
        <div class="form-group">
            <label>PLAYERS</label>
            <select id="num-players">
                <option value="2">2 PLAYERS</option>
                <option value="4">4 PLAYERS</option>
            </select>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <button class="btn" onclick="toggleModal('help-modal', true)">HELP [?]</button>
            <button class="btn" onclick="startGame()">INITIALIZE</button>
        </div>
    </div>

    <div id="game-screen" style="display:none;">
        <div style="display: flex; justify-content: space-between; margin-bottom: 10px; color: var(--accent);">
            <div id="current-player-display">PLAYER 1</div>
            <div>MOVES: <span id="moves-left">5</span></div>
        </div>
        <div class="board-container" id="shake-target">
            <canvas id="game-canvas"></canvas>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <button class="btn btn-yield" onclick="yieldTurn()">CHICKEN OUT</button>
            <button class="btn" style="margin-top: 10px;" onclick="location.reload()">REBOOT</button>
        </div>
    </div>

    <div class="modal-overlay" id="help-modal">
        <div class="modal-content">
            <h2 style="color: var(--accent);">SYSTEM MANUAL</h2>
            <div class="help-text">
                * <b>OBJECTIVE:</b> Move your node and claim territory. Don't get trapped!<br><br>
                * <b>MOVEMENT:</b> You have 5 moves per turn. You can slide in any direction until you hit a wall or a claimed tile.<br><br>
                * <b>TRAILS:</b> Every square you leave becomes a wall. <br><br>
                * <b>YIELDING:</b> Use 'Chicken Out' to forfeit. A true pilot never yields.
            </div>
            <button class="btn" onclick="toggleModal('help-modal', false)">UNDERSTOOD</button>
        </div>
    </div>

    <div class="modal-overlay" id="win-modal">
        <div class="modal-content">
            <h2 id="winner-text" style="color: var(--accent); margin-bottom: 20px;"></h2>
            <button class="btn" onclick="location.reload()">CONTINUE</button>
        </div>
    </div>

    <script>
        // --- AUDIO ENGINE ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(freq, type, duration, vol, slideFreq = null) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            if(slideFreq) osc.frequency.exponentialRampToValueAtTime(slideFreq, audioCtx.currentTime + duration);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + duration);
        }

        const sounds = {
            click: () => playSound(800, 'square', 0.05, 0.1),
            boop: () => playSound(400, 'sine', 0.2, 0.2),
            chicken: () => playSound(300, 'sawtooth', 0.6, 0.2, 50)
        };

        // --- GAME LOGIC ---
        const state = {
            gridSize: 12, numPlayers: 2, movesRemaining: 5,
            grid: [], players: [], currentPlayer: 0, cellSize: 0
        };

        const fx = { particles: [], pings: [], shake: 0 };
        const COLORS = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#a29bfe'];

        class Particle {
            constructor(x, y, color, sizeMult = 1) {
                this.x = x; this.y = y; this.color = color;
                this.size = (Math.random() * 3 + 1) * sizeMult;
                this.vx = (Math.random() - 0.5) * 10 * sizeMult;
                this.vy = (Math.random() - 0.5) * 10 * sizeMult;
                this.life = 1.0;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life -= 0.02; }
        }

        class Ping {
            constructor(x, y, color = '#00d4aa') { this.x = x; this.y = y; this.radius = 0; this.life = 1.0; this.color = color; }
            update() { this.radius += 2.5; this.life -= 0.04; }
        }

        let canvas, ctx;

        function toggleModal(id, show) {
            document.getElementById(id).style.display = show ? 'flex' : 'none';
        }

        function startGame() {
            audioCtx.resume();
            state.gridSize = parseInt(document.getElementById('grid-size').value);
            state.numPlayers = parseInt(document.getElementById('num-players').value);
            state.grid = Array(state.gridSize).fill().map(() => Array(state.gridSize).fill(0));
            
            const starts = [{x:0, y:0}, {x:state.gridSize-1, y:state.gridSize-1}, {x:state.gridSize-1, y:0}, {x:0, y:state.gridSize-1}];
            for(let i=0; i<state.numPlayers; i++) {
                state.players.push({ x: starts[i].x, y: starts[i].y, color: COLORS[i], eliminated: false });
            }

            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            state.cellSize = Math.floor(Math.min(window.innerWidth - 60, 450) / state.gridSize);
            canvas.width = canvas.height = state.cellSize * state.gridSize;

            canvas.addEventListener('click', handleInput);
            document.getElementById('setup-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'block';

            calculateValidMoves();
            requestAnimationFrame(updateLoop);
        }

        function yieldTurn() {
            const p = state.players[state.currentPlayer];
            sounds.chicken();
            fx.shake = 20;
            // White flag explosion (Retro "Chicken" animation)
            for(let i=0; i<30; i++) {
                fx.particles.push(new Particle(p.x * state.cellSize + state.cellSize/2, p.y * state.cellSize + state.cellSize/2, '#ffffff', 2));
            }
            p.eliminated = true;
            nextTurn();
        }

        function calculateValidMoves() {
            state.validMoves = [];
            const p = state.players[state.currentPlayer];
            if(p.eliminated) return;

            const dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,-1],[1,-1],[-1,1]];
            dirs.forEach(d => {
                let x = p.x + d[0], y = p.y + d[1];
                let lastValid = null;
                while(x >=0 && x < state.gridSize && y >=0 && y < state.gridSize && state.grid[y][x] === 0) {
                    // Check other players' current positions
                    if(state.players.some(op => !op.eliminated && op.x === x && op.y === y)) break;
                    lastValid = {x, y};
                    x += d[0]; y += d[1];
                }
                if(lastValid) state.validMoves.push(lastValid);
            });
        }

        function handleInput(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / state.cellSize);
            const y = Math.floor((e.clientY - rect.top) / state.cellSize);
            const move = state.validMoves.find(m => m.x === x && m.y === y);
            if(move) makeMove(x, y);
        }

        function makeMove(x, y) {
            const p = state.players[state.currentPlayer];
            fx.shake = 8;
            fx.pings.push(new Ping(x * state.cellSize + state.cellSize/2, y * state.cellSize + state.cellSize/2));
            for(let i=0; i<12; i++) fx.particles.push(new Particle(p.x * state.cellSize + state.cellSize/2, p.y * state.cellSize + state.cellSize/2, p.color));

            state.grid[p.y][p.x] = state.currentPlayer + 1;
            p.x = x; p.y = y;
            state.movesRemaining--;
            sounds.click();

            if(state.movesRemaining <= 0) {
                nextTurn();
            } else {
                calculateValidMoves();
                if(state.validMoves.length === 0) { p.eliminated = true; nextTurn(); }
            }
            updateHUD();
        }

        function nextTurn() {
            state.currentPlayer = (state.currentPlayer + 1) % state.numPlayers;
            state.movesRemaining = 5;
            sounds.boop();
            
            const activePlayers = state.players.filter(p => !p.eliminated);
            if(activePlayers.length <= 1) {
                endGame(activePlayers[0]);
                return;
            }

            if(state.players[state.currentPlayer].eliminated) {
                nextTurn();
            } else {
                calculateValidMoves();
                if(state.validMoves.length === 0) {
                    state.players[state.currentPlayer].eliminated = true;
                    nextTurn();
                }
            }
            updateHUD();
        }

        function updateHUD() {
            document.getElementById('moves-left').innerText = state.movesRemaining;
            const cp = state.players[state.currentPlayer];
            document.getElementById('current-player-display').innerText = "PLAYER " + (state.currentPlayer + 1);
            document.getElementById('current-player-display').style.color = cp.color;
        }

        function endGame(winner) {
            document.getElementById('winner-text').innerText = winner ? `PLAYER ${state.players.indexOf(winner)+1} DOMINATES` : "SYSTEM CRASH: NO SURVIVORS";
            toggleModal('win-modal', true);
        }

        function updateLoop() {
            ctx.clearRect(0,0,canvas.width, canvas.height);
            fx.particles = fx.particles.filter(p => p.life > 0);
            fx.particles.forEach(p => p.update());
            fx.pings = fx.pings.filter(p => p.life > 0);
            fx.pings.forEach(p => p.update());
            
            const shakeX = (Math.random()-0.5) * fx.shake;
            const shakeY = (Math.random()-0.5) * fx.shake;
            fx.shake *= 0.9;

            ctx.save();
            ctx.translate(shakeX, shakeY);

            // Grid & Tiles
            for(let y=0; y<state.gridSize; y++) {
                for(let x=0; x<state.gridSize; x++) {
                    ctx.strokeStyle = '#1e252e';
                    ctx.strokeRect(x*state.cellSize, y*state.cellSize, state.cellSize, state.cellSize);
                    if(state.grid[y][x] > 0) {
                        ctx.fillStyle = COLORS[state.grid[y][x]-1] + '44';
                        ctx.fillRect(x*state.cellSize+2, y*state.cellSize+2, state.cellSize-4, state.cellSize-4);
                    }
                }
            }

            // Valid moves (if current player isn't eliminated)
            state.validMoves.forEach(m => {
                ctx.fillStyle = 'rgba(0, 212, 170, 0.15)';
                ctx.fillRect(m.x*state.cellSize+4, m.y*state.cellSize+4, state.cellSize-8, state.cellSize-8);
            });

            // Players
            state.players.forEach((p, i) => {
                if(p.eliminated) return;
                ctx.shadowBlur = 15; ctx.shadowColor = p.color;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x*state.cellSize + state.cellSize/2, p.y*state.cellSize + state.cellSize/2, state.cellSize/3, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            // FX Rendering
            fx.particles.forEach(p => {
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });
            fx.pings.forEach(p => {
                ctx.globalAlpha = p.life; ctx.strokeStyle = p.color; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2); ctx.stroke();
            });

            ctx.restore();
            requestAnimationFrame(updateLoop);
        }
    </script>
<script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-database-compat.js"></script>

<script>
  // 2. Paste your config from Step 1 here
const firebaseConfig = {
  apiKey: "AIzaSyD2TJ0yDozk-QMsLvgAr8rlUTGs65B3KNI",
  authDomain: "gridlock-2ebd2.firebaseapp.com",
  projectId: "gridlock-2ebd2",
  storageBucket: "gridlock-2ebd2.firebasestorage.app",
  messagingSenderId: "757731087306",
  appId: "1:757731087306:web:3ce1fb926b1a5a36487533",
  measurementId: "G-2VMRRZMF9Z"
};

  
  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database().ref('gridlock-game-room1'); // Use a unique room name

  // 3. Update makeMove to send to Firebase instead of local state
  function makeMove(x, y) {
      // Instead of changing local state here, we push to the cloud
      db.update({
          lastMove: { x, y, playerIndex: state.currentPlayer, timestamp: Date.now() },
          movesRemaining: state.movesRemaining - 1,
          currentPlayer: state.movesRemaining === 1 ? (state.currentPlayer + 1) % state.numPlayers : state.currentPlayer
      });
  }

  // 4. LISTEN for changes (This runs on EVERYONE'S device)
  db.on('value', (snapshot) => {
      const data = snapshot.val();
      if (!data) return;

      // Update the local game board based on what the database says
      if (data.lastMove) {
          executeMoveLocally(data.lastMove.x, data.lastMove.y, data.lastMove.playerIndex);
          state.currentPlayer = data.currentPlayer;
          state.movesRemaining = data.movesRemaining;
          updateHUD();
      }
  });
</script>
</body>
</html>
